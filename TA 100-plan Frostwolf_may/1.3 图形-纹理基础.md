# 1.3 纹理基础

## 纹理介绍

### 定义

* 一般角度：一张图片（二维纹理）
* 程序角度：存储信息的n维数组（n维纹理），一种可供着色器读写的结构化存储格式。当然最常用的是二维纹理和一维纹理

表面上，纹理存储着颜色信息。但实际上，纹理的作用不仅仅是存储颜色信息，还可以存储法线信息、高度信息、切线信息、AO、metallic、roughness等等，用途十分广泛。

### 意义

因为计算机硬件的限制，如果我们为了增加模型的细节而在游戏中使用顶点数量巨大的模型，就会在渲染时造成大量的性能消耗，以至于不能正常运行。为了在游戏流畅运行的同时，保证模型较高的细节程度，纹理技术的应用是十分必要的。

总体来说，纹理技术就是为了对高精度模型的表面进行模拟，从而在低精度模型上，以一个较低的代价来表现出高精度模型的大部分细节的一种技术。没错，这里说的”大部分细节“，意味着纹理技术并不能还原出和高精度模型完全一致的细节。毕竟纹理应用的对象是低精度的模型，其模拟出的”细节“并不是真实存在的由顶点的编辑产生的细节。因此，如果近距离地观察高精度模型与应用纹理的低精度模型，会发现两者的一些区别，但是这种差距是完全可以接受的。对比高精度模型，纹理技术的应用有以下几个优势：

* 减少了游戏包体的大小
* 提高了游戏渲染的性能
* 保留了高精度模型的大部分细节



## 纹理管线

![image-20220504213831654](C:\Users\52781\AppData\Roaming\Typora\typora-user-images\image-20220504213831654.png "texture_pipeline")

### 投影函数（projector function）

* 将模型空间中的顶点位置投影到纹理坐标的空间中

  * 模型空间中的顶点位置，即局部坐标
  * 纹理坐标空间，听上去是个新名词，但其实就是建模中熟悉的UV空间
  * 投影函数即是局部坐标——纹理坐标（UV坐标）的映射

* 这里的投影函数与MVP矩阵中的投影矩阵是两个不同的概念

* 通常情况下，建模师在建模的流程中会有一步“UV展开”的操作，即根据该模型，手动建立一对该模型的局部坐标到UV坐标的一对一映射关系。这是针对该模型定制的UV映射，完成映射的UV坐标将直接存储在模型文件中。然后，美术会根据手动定制的UV坐标绘制针对于该模型的各种纹理贴图，这样绘制的纹理贴图一般不能复用到其他的模型中，而是专属于这个定制的UV坐标的模型

  * 这种情况下，坐标间映射的关系当然不能用一个统一的投影表达式来表示

  * 统一的投影表达式，如球形投影，平面投影等，更多是作为手动进行UV展开前的第一步。先将所有顶点进行统一的投影，再根据实际情况调整顶点的UV坐标进行手动展开

    <img src="E:\Backup Folder\LiHaoyu\github\MyImageBed\My-Learn\TA 100-plan Frostwolf_may\1.3 图形-纹理基础\projector funtion.png" alt="image-20220504224850196" style="zoom:50%;" />

* 此外，一些技术还会应用到特殊的投影函数，这种映射不是在**建模时期**确定的，而是在**渲染阶段**进行实时计算的。例如天空盒（Cube map）、IBL（image based lighting）等。这种情况下使用的纹理贴图并不针对某个模型，对场景中的所有模型都具有适用性



### 对应函数（corresponder function）

* 在上面投影函数的基础上进行的一步扩展（可选择）
* 对应函数比较简单，也比较常用，但不是必须的。其相当于对UV坐标再做一次变换（映射），例如最常见的旋转、缩放、平移等操作。这里可以举一些例子：
  * 对于地板，一般是进行重复的纹理采样。若我们希望增加纹理的复用程度，即让纹理在地板上出现得更密集（每格地板的面积更小），则可以对UV坐标进行放大（没错是放大）。因为一般情况下UV坐标的范围是[0,1]，若我们设置超出的部分进行重复地采样（使用小数部分继续对纹理进行采样），就能在原本的模型上采样出更多的纹理
  * 若我们希望纹理旋转起来，就可以计算一个随时间变换的旋转矩阵，使得UV坐标旋转起来，在采样后就能模拟出旋转的效果，但实际上模型的顶点是没有变化的



### 纹理采样（sampling）

* 使用上面计算出来的最终的UV坐标对纹理进行采样，得到具体的纹理值

* 以OpenGL为例，其2D纹理在着色器中的类型为Sampler2D，即2D采样器，声明如下：

  ```
  Uniform Sampler2D base_tex;
  ```

  * 其中，一个Sampler2D对象就对应一张2D纹理
  * Uniform表示这个对象在这个模型渲染的整个过程中是一个不变量



#### 依赖纹理读取

这里其实包含了两种含义：

1. 在移动设备中，当在片元着色器中采样获取纹理值时，不使用原始未经过任何修改的纹理坐标（从顶点着色器直接传过来的）时都会发生依赖纹理读取（即使仅仅进行了一些简单的计算，如偏移等），在一些旧设备上不发生依赖纹理读取时效率会高很多
2. 在早期GPU中，依赖纹理读取指的是一个纹理坐标值依赖于之前采样的纹理值，例如法线纹理改变了表面的法线，进而改变了反射的cube map的采样结果

依赖纹理读取可能对性能有一些影响，因此我们需要尽量把纹理坐标的计算放到顶点着色器里进行。根据我的理解，这部分的性能损耗的产生可能是因为在顶点着色器中的计算是针对顶点的，在片元着色器中的计算是针对片元的。而一般情况下，片元的数量远远大于顶点的数量。所以，如果我们在顶点着色器中完成纹理坐标的计算，在片元着色器中就可以直接使用通过插值计算出来的片元上的纹理坐标。而如果在片元着色器中进行计算，则相当于每个片元都要重新计算纹理坐标，无疑会造成一定的性能损耗。但是实际上我觉得在现代的GPU中这部分的损耗已经比较小了，如果实际操作中发现必须要在片元着色器中才能确定最终的纹理坐标的话，不用因为这部分的性能损耗而放弃。





#### 采样设置

<img src="E:\Backup Folder\LiHaoyu\github\MyImageBed\My-Learn\TA 100-plan Frostwolf_may\1.3 图形-纹理基础\sampling.png" alt="image-20220504234022607" style="zoom:50%;" />

* 当使用最终的纹理坐标对纹理进行采样时，根据纹理的分辨率，将纹理坐标进行缩放（如纹理分辨率为256x256，就将纹理坐标的两个分量都乘256），然后进行采样
* 这里会发现，采样的坐标是一个浮点值，而纹理的像素索引值时是整数值。因此我们需要一个具体的采样设置（采样策略）来告诉GPU如何进行采样，即根据这个浮点坐标计算出一个确定的采样值
* 在一个纹理对象中，不仅仅包含纹理的信息，还需要包含该纹理的采样设置



##### 环绕模式（Wrap Mode）

* OpenGL：包装模式（Wrapping Model）
* DirectX：纹理寻址模式（Texture Addressing Mode）

决定纹理坐标在超出[0,1]的范围时纹理的采样方式，较常用的设置有：

* 重复（Repeat）
* 镜像（Mirror）
* 钳制（Clamp）：超出部分的颜色使用其超出时边缘的颜色
* 边界（Border）：超出部分的颜色使用一个固定值

其效果依次可以由下面的示例直观地表现：

![image-20220505000400091](E:\Backup Folder\LiHaoyu\github\MyImageBed\My-Learn\TA 100-plan Frostwolf_may\1.3 图形-纹理基础\wrap.png)



##### 过滤模式（Filter Mode）













## 优化与纹理应用









## 参考链接

* https://blog.csdn.net/lele0503/article/details/105881309
* https://zhuanlan.zhihu.com/p/365518995
* http://www.javashuo.com/article/p-vilijzko-dx.html
* https://blog.csdn.net/lele0503/article/details/105881309







